# Ch2 程序结构

## 命名

1. 变量名**区分大小写**

2. Go语言封装维度是**包**，如果一个实体在函数外声明，它将对包里的所有源文件可见，实体第一个字母的大小写决定其可见性是否跨包。

3. 包名本身总是由小写字符组成。

4. Go使用”驼峰式“风格，使用大写字母而不是下划线。

5. 像HTML这样的首字符缩写词，通常使用**相同的大小写**。

```go
htmlEscape	 // ok
HTMLEscapse  // ok
escapeHtml	 // no
```

## 声明

声明给一个程序实体命名，并且设定其部分或全部属性。

变量声明（var）

常量声明（const）

类型声明（type）

函数声明（func）

### Go程序组成

go程序存储在一个或者多个以.go为后缀的文件里。

每一个文件以package声明开头，表明文件属于哪个包。

package声明后面是import声明。

然后是**包级别**的类型，变量，常量，函数声明，**不区分顺序**。

####  可见性

包级别的实体名字不仅对于包含其声明的源文件可见，而且对于同一个包里面的所有源文件都可见。

换句话说，首字符大小写只是决定对于其他包是否可见。在同一个包内，无论首字符大小写都是可见的。

#### 函数声明

与C语言不同，go语言没有区分函数声明与定义。

函数声明包括 一个函数名，一个参数列表，一个可选的返回值列表，函数体 四部分。

## 变量

### 变量类型与零值

| 变量类型       | 具体类型                        | 零值                     |
| -------------- | ------------------------------- | ------------------------ |
| 数字           |                                 | 0                        |
| 布尔           |                                 | false                    |
| 字符串         |                                 | "" (空字符串)            |
| 接口和引用类型 | slice，map，channel，函数，指针 | nil                      |
| 复合类型       | 数组或结构体                    | 所有元素或者在成员的零值 |

### 变量声明
```go
var name type = expression
```

类型和表达式可以省略一个，不可都省略。

类型省略，类型由初始化表达式决定；

表达式省略，变量被初始化为对应类型的零值。



go语言的零值有什么用？

**go语言通过零值机制保证所有变量都是良好定义的，不存在未初始化变量**。可以简化代码，不需要额外工作就能使用变量，而不会出现错误或者不可预料行为。

<font color=red>包级别的初始化在main开始之前进行</font>

<font color=red>局部变量初始化和声明一样，在函数执行期间进行</font>

### 指针

指针的值是变量的地址。不是所有的值都有地址，但是所有的变量都有地址。

代表变量的表达式，是**唯一**可以应用取地址操作符&的表达式。也就是说，只有变量才可以取地址，go没有函数指针，因为函数本来就是引用类型。

```go
func f() {/*...*/}
var a = f
a()
```

获取函数指针可以通过变量赋值获取（本质上也是获取变量的指针，而不是函数的指针）

```go
func f() {}
var a = f
p := &a
(*p)()
```

**函数返回局部变量的指针是非常安全的。**

```go
// 不同于C/C++，编译器可以选择使用堆或栈上的空间来分配，这个选择不是基于new或者var关键字，而是基于逃逸分析
// 通过调用f产生的局部变量v，即使在调用返回后依然存在，指针v依然引用它
func f() *int {
    v := 1
    return &v
}
a := f()
```

### new函数
使用表达式new(T)创建一个未命名的T类型变量，**初始化为T类型的零值**，并且返回该类型的**指针（*T）**

大多数情况下，每次调用new都会创建一个新的变量，返回不同的地址。例外：两个变量的类型不携带任何信息且是零值，例如```struct{}``` 或者`[0]int`，当前实现下，具有相同的地址。

<font color=red>new(T) 与 make(T) 的区别</font>

new是一个**预声明的函数**，不是关键字，所以可以被重定义，比如定义局部变量`f(new, old int) {}`

### 变量生命周期与逃逸分析

#### 包级别变量

包级别变量的生命周期是整个程序的执行时间。（相当于C/C++中的全局变量）

#### 局部变量

每次执行声明语句时创建一个新的实例，变量一直生存到它变得不可访问，此时它占用的存储空间被回收。

函数的参数和返回值也是局部变量，它们在其闭包函数被调用时创建。<font color=red>闭包函数是指什么？</font>

**变量可以分配在堆上或栈上，这个由逃逸分析结果决定而不是new 或者var 决定。**

1. 编译器怎么决定变量分配在栈上还是堆上？

```go
var g *int
func f() {
    x := 1
    g = &x
}
```

x 一定使用堆空间，因为它在f函数返回后还可以从g变量访问，尽管它被声明为一个局部变量。这种情况我们说**x 从 f 中逃逸**。

```go
func g() {
    y := new(int)
    *y = 1
}
```

当函数g返回时，变量\*y变得不可访问，可以回收，因为\*y没有从g中逃逸，所以编译器可以安全地在栈上分配*y，即便使用new函数创建它。

每一次变量逃逸都需要一次额外的内存分配过程（因为在堆上分配，需要在当前栈保存变量地址）

2. go语言GC，什么情况下会内存泄漏？

长生命周期对象保持短生命周期对象不必要的指针，特别是全局变量中，会阻止GC回收短生命周期的对象空间。

### 变量可比较性

两个变量使用 == 和 != 进行比较与可赋值性有关：在任何比较中，第一个操作说相对于第二个操作数类型必须是可赋值的，或者可以反过来赋值。

### Typedef 类型声明

给一个已有的类型起一个别名。

类型声明通常出现在**包级别**，命名的类型在整个包中可见。

与变量一样，如果名字首字符大写，其他的包也可以访问它。

声明的类型与原始类型是不同的类型。即使两个类型声明使用相同的底层类型，它们也不是相同的类型。也就是说他们不能使用算术表达式进行比较或合并。如果需要进行运算，需要进行**显式类型转换**。

命名类型的值 可以与 其他相同类型的值 或者 底层类型相同的**未命名类型**的值 相比较，但是不同命名类型的值不能直接比较

```go
type Celsius float64
type Fahrenheit float64
var c Celsius
var f Fahrenheit
c == 0 // true
c == f // 编译错误！类型不匹配
c == Celsius(f)	// true
```

#### 类型转换

对于每个类型T，都有一个对应的类型转换操作T(x)将值x转换为类型T。

如果 两个类型具有相同的底层类型 或者 二者都是指向相同底层类相关变量的未命名指针类型，则二者可以互相转换。这种类型转换不改变值的表达方式，仅改变类型（即改变对值的理解）。

另一方面，数字类型间的转换，字符串和一些slice类型间的转换是允许的。这些转换是会改变值的表达方式的。例如，浮点型转换为整型会丢失小数部分，从字符串转换成字节（[]byte）slice会分配一份字符串数据副本。

## 包与文件

一个包的源代码保存在一个或者多个以**.go**结果的文件中，文件所在目录名的尾部就是包的导入路径。即`$GOPATH/src/...`之后的部分

包级别的常量名字以大写字母开头（实际上也是对其他包可见），不要求全是大写字符`temp.AbsoluteZeroC`

### 包的导入

导入路径从$GOPATH/src后续截取。

包名为导入路径的最后一段。

```go
import "testpkg/test1/test"		// 导入路径 $GOPATH/src/testpkg/test1/test
test.f()		 // 包名为test
```



### 包的初始化

go工具首先会分析依赖，如果存在循环依赖，比如A.go文件变量a1 依赖B.go文件变量b1，B.go文件变量b2依赖A文件变量a2，则会报错，编译无法进行。

```go
A.a1 = B.b1
B.b2 = A.a2 
```

在没有循环引用的前提下，go工具会对文件根据进行排序。

单个文件编译，初始化从包级别的变量开始，根据依赖的顺序进行初始化。如果没有依赖关系，则按照变量的声明顺序初始化，实际上也没有影响。

```go
var a = b + c	// 3.等待b,c初始化后，初始化a为3
var b = f()		// 2.调用f()初始化b为2
var d = 2		// 1.初始化d为2
var c = 1		// 1.初始化c为1
func f() int { return c + 1 }
```

#### init 函数

包里的**每一个文件**，都可以包含**任意数量**的init函数。一个文件可以多个同名的init函数。

```go
func init() {/*初始化包级别的变量*/}
```

**init函数不能被调用或者被引用**，也没有返回值（因为不能被调用，所以返回值也没有意义）。

init函数在程序启动的时候自动执行。

init函数初始化的变量如果有依赖，则按照依赖顺序执行，没有依赖按照声明顺序执行。

#### 总结

go语言与其他语言不同，对于包的初始化顺序，由go工具进行排序，无需程序员操心。程序员需要保证的时候包之间或者包内变量之间没有互相循环引用的情况。

无论是包之间的初始化顺序，同一个包中不同文件的初始化顺序，还是同一个文件中变量的初始化顺序。都是根据依赖（拓扑排序）决定初始化顺序，如果没有依赖顺序，则按照导入的顺序（文件）或声明顺序（变量）。

初始化时自底向上的，main包最后初始化，在main函数执行之前，所有包已经初始化完毕。

## GoModule

<font color=red>TODO</font>



## 作用域

声明将名字与实体关联起来。声明的作用域是指用到声明时，所声明名字的源代码段。

### 作用域与生命周期

不要将作用域与生命周期混淆。

声明的作用域时声明在程序文本中出现的区域，它是一个编译时属性。

变量的生命周期是变量在程序执行期间能被程序的其他部分所引用的起止时间，它是一个运行时属性。

### 块

由大括号围起来的一个语句序列。

在语法快内部声明变量对块外部不可见。语法块把声明包围起来，并且决定了声明的可见性。

没有显式包含在大括号中的声明代码，统称为词法块。

语法块也是词法块。

**一个声明的词法块决定声明作用域大小。**

1. 内置类型，内置函数，内置常量在全局块中声明并且对整个程序可见。

2. 在包级别（任何函数外）的声明，可以被包里的任何文件引用。

3. 导入的包是文件级别的，导入的包之能在同一个文件内引用。但是在其他文件没有import的前提下，不能在同一个包的其他文件引用。

4. 局部变量仅可在同一个函数中或者仅仅是函数的一部分所引用。

一个程序可以包含多个同名的变量，前提时他们在不同词法块中。

当编译器遇到一个名字的引用时，将从最内层的封闭词法块到全局块寻找其声明。
如果内层和外层块都存在这个声明，内层的先被找到。
**内层声明经覆盖外层声明，使外层声明不可用。**
```go
func main() {
    x := "hello!"
    // for语句隐式词法块
    for i := 0; i < len(<font color=red>x</font>); i++ {  // 花括号之内，显示词法块,包含于for语句的隐式词法块
       	x := x[1]
        if x != '!' {
            x := x + 'A' - 'a'
            fmt.Printf("%c", x)		// Hello
        }
    }  
}
```
特殊的，for循环创建了两个词法块，一个是循环体本身的显式词法块。另一个是隐式词法块，包含了一个闭合结构，其中就由初始化语法中声明的变量，如变量i。

隐式块中声明的变量作用域包括条件，后置条件（i++），以及for语句体本身。隐式语法块包含了显式语法块。


