# Ch2 程序结构

## 命名

1. 变量名**区分大小写**

2. Go语言封装维度是**包**，如果一个实体在函数外声明，它将对包里的所有源文件可见，实体第一个字母的大小写决定其可见性是否跨包。

3. 包名本身总是由小写字符组成。

4. Go使用”驼峰式“风格，使用大写字母而不是下划线。

5. 像HTML这样的首字符缩写词，通常使用**相同的大小写**。

```go
htmlEscape	 // ok
HTMLEscapse  // ok
escapeHtml	 // no
```

## 声明

声明给一个程序实体命名，并且设定其部分或全部属性。

变量声明（var）

常量声明（const）

类型声明（type）

函数声明（func）

### Go程序组成

go程序存储在一个或者多个以.go为后缀的文件里。

每一个文件以package声明开头，表明文件属于哪个包。

package声明后面是import声明。

然后是**包级别**的类型，变量，常量，函数声明，**不区分顺序**。

####  可见性

包级别的实体名字不仅对于包含其声明的源文件可见，而且对于同一个包里面的所有源文件都可见。

换句话说，首字符大小写只是决定对于其他包是否可见。在同一个包内，无论首字符大小写都是可见的。

#### 函数声明

与C语言不同，go语言没有区分函数声明与定义。

函数声明包括 一个函数名，一个参数列表，一个可选的返回值列表，函数体 四部分。



<font color=red>TODO 包的初始化顺序</font>

## 变量

### 变量类型与零值

| 变量类型       | 具体类型                        | 零值                     |
| -------------- | ------------------------------- | ------------------------ |
| 数字           |                                 | 0                        |
| 布尔           |                                 | false                    |
| 字符串         |                                 | "" (空字符串)            |
| 接口和引用类型 | slice，map，channel，函数，指针 | nil                      |
| 复合类型       | 数组或结构体                    | 所有元素或者在成员的零值 |

### 变量声明
```go
var name type = expression
```

类型和表达式可以省略一个，不可都省略。

类型省略，类型由初始化表达式决定；

表达式省略，变量被初始化为对应类型的零值。



go语言的零值有什么用？

**go语言通过零值机制保证所有变量都是良好定义的，不存在未初始化变量**。可以简化代码，不需要额外工作就能使用变量，而不会出现错误或者不可预料行为。

<font color=red>包级别的初始化在main开始之前进行</font>

<font color=red>局部变量初始化和声明一样，在函数执行期间进行</font>

### 指针

指针的值是变量的地址。不是所有的值都有地址，但是所有的变量都有地址。

代表变量的表达式，是**唯一**可以应用取地址操作符&的表达式。也就是说，只有变量才可以取地址，go没有函数指针，因为函数本来就是引用类型。

```go
func f() {/*...*/}
var a = f
a()
```

获取函数指针可以通过变量赋值获取（本质上也是获取变量的指针，而不是函数的指针）

```go
func f() {}
var a = f
p := &a
(*p)()
```

**函数返回局部变量的指针是非常安全的。**

```go
// 不同于C/C++，编译器可以选择使用堆或栈上的空间来分配，这个选择不是基于new或者var关键字，而是基于逃逸分析
// 通过调用f产生的局部变量v，即使在调用返回后依然存在，指针v依然引用它
func f() *int {
    v := 1
    return &v
}
a := f()
```

### new函数
使用表达式new(T)创建一个未命名的T类型变量，**初始化为T类型的零值**，并且返回该类型的**指针（*T）**

大多数情况下，每次调用new都会创建一个新的变量，返回不同的地址。例外：两个变量的类型不携带任何信息且是零值，例如```struct{}``` 或者`[0]int`，当前实现下，具有相同的地址。

<font color=red>new(T) 与 make(T) 的区别</font>

new是一个**预声明的函数**，不是关键字，所以可以被重定义，比如定义局部变量`f(new, old int) {}`

### 变量生命周期与逃逸分析

#### 包级别变量

包级别变量的生命周期是整个程序的执行时间。（相当于C/C++中的全局变量）

#### 局部变量

每次执行声明语句时创建一个新的实例，变量一直生存到它变得不可访问，此时它占用的存储空间被回收。

函数的参数和返回值也是局部变量，它们在其闭包函数被调用时创建。<font color=red>闭包函数是指什么？</font>

**变量可以分配在堆上或栈上，这个由逃逸分析结果决定而不是new 或者var 决定。**

1. 编译器怎么决定变量分配在栈上还是堆上？

```go
var g *int
func f() {
    x := 1
    g = &x
}
```

x 一定使用堆空间，因为它在f函数返回后还可以从g变量访问，尽管它被声明为一个局部变量。这种情况我们说**x 从 f 中逃逸**。

```go
func g() {
    y := new(int)
    *y = 1
}
```

当函数g返回时，变量\*y变得不可访问，可以回收，因为\*y没有从g中逃逸，所以编译器可以安全地在栈上分配*y，即便使用new函数创建它。

每一次变量逃逸都需要一次额外的内存分配过程（因为在堆上分配，需要在当前栈保存变量地址）

2. go语言GC，什么情况下会内存泄漏？

长生命周期对象保持短生命周期对象不必要的指针，特别是全局变量中，会阻止GC回收短生命周期的对象空间。

### 变量可比较性

两个变量使用 == 和 != 进行比较与可赋值性有关：在任何比较中，第一个操作说相对于第二个操作数类型必须是可赋值的，或者可以反过来赋值。